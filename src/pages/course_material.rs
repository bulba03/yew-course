use std::ops::Deref;

use gloo_console::log;
use gloo_net::http::Request;
use serde::{ Deserialize, Serialize };
use serde_json::json;
use wasm_bindgen_futures::js_sys::JSON;
use web_sys::HtmlInputElement;
use wasm_bindgen::JsCast;
use yew::{ function_component, prelude::* };
use yew_router::components::Link;
use yew_router::prelude::*;
use yewdux::dispatch;
use yewdux::use_store;
use yewdux::prelude::*;
use crate::app::Route;

use crate::{ api, app::SERVER_URL };
#[derive(Properties, PartialEq)]
pub struct Props {
    pub course_id: i32,
    pub lesson_id: i32
}
pub enum Msg {
    FetchMaterials,
    FetchContent,
    SetContent{content: Html},
    SetMaterials{materials: Vec<String>}
}
pub struct CourseMaterial {
    course_id: i32,
    lesson_id: i32,
    content: Html,
    materials: Vec<String>
}

impl Component for CourseMaterial {
    type Message = Msg;

    type Properties = Props;
    fn create(ctx: &Context<Self>) -> Self {
        log!("Created");
       let s = Self {
            course_id: ctx.props().course_id,
            lesson_id: ctx.props().lesson_id,
            content: Html::default(),
            materials: Vec::new()
       };
       ctx.link().send_message(Msg::FetchContent);
       ctx.link().send_message(Msg::FetchMaterials);
       s
    }
    fn changed(&mut self, ctx: &Context<Self>, _old_props: &Self::Properties) -> bool {
        true
    }
    fn update(&mut self, ctx: &Context<Self>, msg: Self::Message) -> bool {
        log!(self.lesson_id);
        match msg {
            Msg::FetchMaterials => {
                let mut data:Vec<String> = Vec::new();
                data.push(String::from("Типы данных"));
                data.push(String::from("Функции"));
                data.push(String::from("Программирование игры в загадки"));
                // data.push(String::from("Трейты и перечисления"));
                    
                ctx.link().send_message(Msg::SetMaterials { materials: data })
            }
            Msg::FetchContent => {
                match self.lesson_id {
                    1 => {
                        let markdown_input = ONE.to_string();
                        let parser = pulldown_cmark::Parser::new(&markdown_input);
                        let mut html_output = String::new();
                        pulldown_cmark::html::push_html(&mut html_output, parser);
                        let val = Html::from_html_unchecked(html_output.into());
                        ctx.link().send_message(Msg::SetContent { content: val })
                    }
                    2 => {
                        let markdown_input = TWO.to_string();
                        let parser = pulldown_cmark::Parser::new(&markdown_input);
                        let mut html_output = String::new();
                        pulldown_cmark::html::push_html(&mut html_output, parser);
                        let val = Html::from_html_unchecked(html_output.into());
                        ctx.link().send_message(Msg::SetContent { content: val })
                    }
                    3 => {
                        let markdown_input = THREE.to_string();
                        let parser = pulldown_cmark::Parser::new(&markdown_input);
                        let mut html_output = String::new();
                        pulldown_cmark::html::push_html(&mut html_output, parser);
                        let val = Html::from_html_unchecked(html_output.into());
                        ctx.link().send_message(Msg::SetContent { content: val })
                    }
                    _ => {
                        let markdown_input = TWO.to_string();
                        let parser = pulldown_cmark::Parser::new(&markdown_input);
                        let mut html_output = String::new();
                        pulldown_cmark::html::push_html(&mut html_output, parser);
                        let val = Html::from_html_unchecked(html_output.into());
                        ctx.link().send_message(Msg::SetContent { content: val })
                    }
                }
               
            },
            Msg::SetContent{content} => {
                self.content = content;
            },
            Msg::SetMaterials{materials} => {
                self.materials = materials;
            },
        }
        true
    }

    fn view(&self, ctx: &Context<Self>) -> Html {
        
        let materials = self.materials.iter().enumerate().map(|(id, data)| {
            let valid_id = id +1;
            let navigator = ctx.link().navigator().unwrap();
            let course_id = self.course_id.clone();
            

                
            let mut strin = valid_id.to_string();
            strin.push_str(". ");
            strin.push_str(data);
            let mut style = String::new();
            if id as i32 == self.lesson_id {
                style = String::from("color: grey")
            }
            html!{<li>
                <div class="box" style={style}>
                // <button {onclick}>{"Go Home"}</button>
                // <Redirect<Route> to={Route::Lesson{course_id: self.course_id, lesson_id: id as i32 + 1}}/>
                  
                <Link<Route> to={Route::Lesson{course_id: self.course_id, lesson_id: id as i32 + 1}}>
                   {strin} 
                </Link<Route>>
                </div>  
            </li>}
        });
        html! {<>
            <div class="container">
            <div class="columns">
                <div class="column is-narrow">
                <div class="box" style="width:300px">
                
                    <aside class="menu">
                        <p class="menu-label">{"Содержание"}</p>
                    </aside>
                    <ul class="menu-list">
                       {
                        for materials
                       }
                    </ul>
                </div>
                </div>
                <div class="column">
                <div class="box course-info-content">
                {self.content.clone()}
                </div>
                </div>
            </div>
            </div>
            </>
    }
    }
}
const THREE: &str = r#" # Программируем игру в загадки

Давайте окунёмся в Rust, вместе поработав над практическим проектом! В этой главе вы познакомитесь с несколькими общими концепциями Rust, показав, как использовать их в реальной программе. Вы узнаете о `let` , `match`, методах, ассоциированных функциях, внешних контейнерах и многом другом! В следующих главах мы рассмотрим эти идеи более подробно. В этой главе вы просто попрактикуетесь в основах.

Мы реализуем классическую для начинающих программистов задачу — игру в загадки. Вот как это работает: программа генерирует случайное целое число в диапазоне от 1 до 100. Затем она предлагает игроку его угадать. После ввода числа программа укажет, меньше или больше было загаданное число. Если догадка верна, игра напечатает поздравительное сообщение и завершится.

## Настройка нового проекта

Для настройки нового проекта перейдите в каталог *projects*, который вы создали в главе 1, и создайте новый проект с использованием Cargo, как показано ниже:

```console
$ cargo new guessing_game
$ cd guessing_game
```

Первая команда, `cargo new`, принимает в качестве первого аргумента имя проекта (`guessing_game`). Вторая команда изменяет каталог на новый каталог проекта.

Загляните в созданный файл *Cargo.toml*:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->

<span class="filename">Файл: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/Cargo.toml}}
```

Как вы уже видели в главе 1, `cargo new` создаёт программу «Hello, world!». Посмотрите файл *src/main.rs*:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/src/main.rs}}
```

Теперь давайте скомпилируем программу «Hello, world!» и сразу на этом же этапе запустим её с помощью команды `cargo run`:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/output.txt}}
```

Команда `run` пригодится, когда необходимо ускоренно выполнить итерацию проекта. Именно так мы собираемся делать в этом проекте, быстро тестируя каждую итерацию, прежде чем перейти к следующей.

Снова откройте файл *src/main.rs*. Весь код вы будете писать в нем.

## Обработка догадки

Первая часть программы запрашивает ввод данных пользователем, обрабатывает их и проверяет, что они в ожидаемой форме. Начнём с того, что позволим игроку ввести догадку. Вставьте код из листинга 2-1 в *src/main.rs*.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:all}}
```

<span class="caption">Листинг 2-1: код, который получает догадку от пользователя и выводит её на экран</span>

Этот код содержит много информации, поэтому давайте рассмотрим его построчно. Чтобы получить пользовательский ввод и затем вывести результат, нам нужно включить в область видимости библиотеку ввода/вывода `io`. Библиотека `io` является частью стандартной библиотеки, известной как `std`:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:io}}
```

По умолчанию в Rust есть набор элементов, определённых в стандартной библиотеке, которые он добавляет в область видимости каждой программы. Этот набор называется *прелюдией*, и вы можете изучить его содержание [в документации стандартной библиотеки].

Если тип, который требуется использовать, отсутствует в прелюдии, его нужно явно ввести в область видимости с помощью оператора `use`. Использование библиотеки `std::io` предоставляет ряд полезных функциональных возможностей, включая способность принимать пользовательский ввод.

Как уже отмечалось в главе 1, функция `main` является точкой входа в программу:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:main}}
```

Ключевое слово `fn` объявляет новую функцию, круглые скобки `()` показывают, что у функции нет входных параметров, фигурная скобка `{` - обозначение начала тела функции.

Также в главе 1 упоминалось, что `println!` — это макрос, который выводит строку на экран:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print}}
```

Этот код показывает информацию о ходе игры и запрашивает пользовательский ввод.

### Хранение значений с помощью переменных

Далее мы создаём *переменную* для хранения пользовательского ввода, как показано ниже:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:string}}
```

Вот теперь программа становится интереснее! В этой маленькой строке на самом деле происходит очень многое. Для создания переменной мы используем оператор `let`. Вот ещё один пример:

```rust,ignore
let apples = 5;
```

Эта строка создаёт новую переменную с именем `apples` и привязывает её к значению 5. В Rust переменные неизменяемы по умолчанию, то есть как только мы присвоим переменной значение, оно не изменится. Мы подробно обсудим эту концепцию в разделе ["Переменные и изменчивость".]<!-- ignore --> в главе 3. Чтобы сделать переменную изменяемой, мы добавляем `mut` перед её именем:

```rust,ignore
let apples = 5; // неизменяемая
let mut bananas = 5; // изменяемая
```

>  Примечание: сочетание знаков `//` начинает комментарий, который продолжается до конца строки. Rust игнорирует всё, что находится в комментариях. Мы обсудим комментарии более подробно в [Главе 3]<!-- ignore -->.
>

Возвращаясь к программе игры "Угадайка" — теперь вы знаете, что `let mut guess` предоставит изменяемую переменную с именем `guess`. Знак равенства (`=`) сообщает Rust, что сейчас нужно связать что-то с этой переменной. Справа от знака равенства находится значение, связанное с `guess`, которое является результатом вызова функции `String::new`, возвращающей новый экземпляр `String`. <a data-md-type="raw_html" href="../std/string/struct.String.html">`String`</a> — это тип строки, предоставляемый стандартной библиотекой, который является расширяемым фрагментом текста в кодировке UTF-8.

Синтаксис `::` в строке `::new` указывает, что `new` является ассоциированной функцией типа `String`. *Ассоциированная функция* — это функция, реализованная для типа, в данном случае `String`. Функция `new` создаёт новую пустую строку. Функцию `new` можно встретить во многих типах, это типичное название для функции, которая создаёт новое значение какого-либо типа.

В конечном итоге строка `let mut guess = String::new();` создала изменяемую переменную, которая связывается с новым пустым экземпляром `String`. Фух!

### Получение пользовательского ввода

Напомним: мы подключили функциональность ввода/вывода из стандартной библиотеки с помощью `use std::io;` в первой строке программы. Теперь мы вызовем функцию `stdin` из модуля `io`, которая позволит нам обрабатывать пользовательский ввод:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:read}}
```

Если бы мы не импортировали библиотеку `io` с помощью `use std::io` в начале программы, мы все равно могли бы использовать эту функцию, записав её вызов как `std::io::stdin`. Функция `stdin` возвращает экземпляр [`std::io::Stdin`], который является типом, представляющим дескриптор стандартного ввода для вашего терминала.

Далее строка `.read_line(&mut guess)` вызывает метод [`read_line`] на дескрипторе стандартного ввода для получения ввода от пользователя. Мы также передаём `&mut guess` в качестве аргумента `read_line`, сообщая ему, в какой строке хранить пользовательский ввод. Главная задача `read_line` — принять все, что пользователь вводит в стандартный ввод, и сложить это в строку (не переписывая её содержимое), поэтому мы передаём эту строку в качестве аргумента. Строковый аргумент должен быть изменяемым, чтобы метод мог изменить содержимое строки.

Символ `&` указывает, что этот аргумент является *ссылкой*, которая предоставляет возможность нескольким частям вашего кода получить доступ к одному фрагменту данных без необходимости копировать эти данные в память несколько раз. Ссылки — это сложная функциональная возможность, а одним из главных преимуществ Rust является безопасность и простота использования ссылок. Чтобы дописать эту программу, вам не понадобится знать много таких подробностей. Пока вам достаточно знать, что ссылки, как и переменные, по умолчанию неизменяемы. Соответственно, чтобы сделать её изменяемой, нужно написать `&mut guess`, а не `&guess`. (В главе 4 ссылки будут описаны более подробно).

<!-- Old heading. Do not remove or links may break. -->

<a id="handling-potential-failure-with-the-result-type"></a>

### Обработка потенциального сбоя с помощью типа `Result`

Мы всё ещё работаем над этой строкой кода. Сейчас мы обсуждаем третью строку, но обратите внимание, что она по-прежнему является частью одной логической строки. Следующая часть — метод:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:expect}}
```

Мы могли бы написать этот код так:

```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

Однако одну длинную строку трудно читать, поэтому лучше разделить её. При вызове метода с помощью синтаксиса `.method_name()` часто целесообразно вводить новую строку и другие пробельные символы, чтобы разбить длинные строки. Теперь давайте обсудим, что делает эта строка.

Как упоминалось ранее, `read_line` помещает всё, что вводит пользователь, в строку, которую мы ему передаём, но также возвращает значение `Result`. <a data-md-type="raw_html" href="../std/result/enum.Result.html">`Result`</a><!-- ignore --> — это [*перечисление*]<!-- ignore -->, часто называемое *enum*, то есть тип, который может находиться в одном из нескольких возможных состояний. Мы называем каждое такое состояние *вариантом*.

В [Главе 6](ch06-00-enums.html) рассмотрим перечисления более подробно. Задачей типов `Result` является кодирование информации для обработки ошибок.

Вариантами `Result` являются `Ok` и `Err`. Вариант `Ok` указывает, что операция завершилась успешно, а внутри `Ok` находится успешно сгенерированное значение. Вариант `Err` означает, что операция не удалась, а `Err` содержит информацию о причинах неудачи.

Значения типа `Result`, как и значения любого типа, имеют определённые для них методы. У экземпляра `Result` есть [метод `expect`]<!-- ignore -->, который можно вызвать. Если этот экземпляр `Result` является значением `Err`, `expect` вызовет сбой программы и отобразит сообщение, которое вы передали в качестве аргумента. Если метод `read_line` возвращает `Err`, то это, скорее всего, результат ошибки базовой операционной системы. Если экземпляр `Result` является значением `Ok`, `expect` возьмёт возвращаемое значение, которое удерживает `Ok`, и вернёт вам только это значение, чтобы вы могли его использовать далее. В данном случае это значение представляет собой количество байтов, введённых пользователем.

Если не вызвать `expect`, программа скомпилируется, но будет получено предупреждение:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-02-without-expect/output.txt}}
```

Rust предупреждает о неиспользованном значении `Result`, возвращаемого из `read_line`, показывая, что программа не учла возможность возникновения ошибки.

Правильный способ убрать предупреждение — это написать обработку ошибок, но в нашем случае мы просто хотим аварийно завершить программу при возникновении проблемы, поэтому используем `expect`. О способах восстановления после ошибок вы узнаете в [главе 9].

### Вывод значений с помощью заполнителей `println!`

Кроме закрывающей фигурной скобки, в коде на данный момент есть ещё только одно место для обсуждения:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print_guess}}
```

Этот код выводит строку, которая теперь содержит ввод пользователя. Набор фигурных скобок `{}` является заполнителем: думайте о `{}` как о маленьких клешнях краба, которые удерживают значение на месте. При печати значения переменной имя переменной может заключаться в фигурные скобки. При печати результата вычисления выражения поместите пустые фигурные скобки в строку формата, затем после строки формата укажите список выражений, разделённых запятыми, которые будут напечатаны в каждом заполнителе пустой фигурной скобки в том же порядке. Печать переменной и результата выражения одним вызовом `println!` будет выглядеть так:

```rust
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
```

Этот код выведет `x = 5 and y + 2 = 12`.

### Тестирование первой части

Давайте протестируем первую часть игры. Запустите её используя `cargo run`:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

На данном этапе первая часть игры завершена: мы получаем ввод с клавиатуры и затем печатаем его.

## Генерация секретного числа

Далее нам нужно сгенерировать секретное число, которое пользователь попытается угадать. Секретное число должно быть каждый раз разным, чтобы в игру можно было играть несколько раз. Мы будем использовать случайное число в диапазоне от 1 до 100, чтобы игра не была слишком сложной. Rust пока не включает функциональность случайных чисел в свою стандартную библиотеку. Однако команда Rust предоставляет [крейт `rand`] с подобной функциональностью.

### Использование крейта для получения дополнительного функционала

Помните, что пакет (crate) - это коллекция файлов исходного кода Rust. Проект, создаваемый нами, представляет собой <br> <em>бинарный пакет (binary crate)</em>, который является исполняемым файлом. Пакет <code>rand</code> - это <em>библиотечный пакет (library crate)</em>, содержащий код, который предназначен для использования в других программах и поэтому не может исполняться сам по себе.

Координация работы внешних пакетов является тем местом, где Cargo на самом деле блистает. Чтобы начать писать код, использующий `rand`, необходимо изменить файл *Cargo.toml*, включив в него в качестве зависимости пакет `rand`. Итак, откройте этот файл и добавьте следующую строку внизу под заголовком секции `[dependencies]`, созданным для вас Cargo. Обязательно укажите `rand` в точности так же, как здесь, с таким же номером версии, иначе примеры кода из этого урока могут не заработать.

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->

<span class="filename">Имя файла: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:8:}}
```

В файле *Cargo.toml* всё, что следует за заголовком, является частью этой секции, которая продолжается до тех пор, пока не начнётся следующая. В `[dependencies]` вы сообщаете Cargo, от каких внешних крейтов зависит ваш проект и какие версии этих крейтов вам нужны. В этом случае мы указываем крейт `rand` со спецификатором семантической версии `0.8.5`. Cargo понимает [семантическое версионирование] (иногда называемое *SemVer*), которое является стандартом для описания версий. Число `0.8.5` на самом деле является сокращением от `^0.8.5`, что означает любую версию не ниже <code>0.8.5</code>, но ниже <code>0.9.0</code>.

Cargo рассчитывает, что эти версии имеют общедоступное API, совместимое с версией <code>0.8.5</code>, и вы получите последние версии исправлений, которые по-прежнему будут компилироваться с кодом из этой главы. Не гарантируется, что версия <code>0.9.0</code> или выше будет иметь тот же API, что и в следующих примерах.

Теперь, не меняя ничего в коде, давайте соберём проект, как показано в листинге 2-2.

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->

```console
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
```

<span class="caption">Листинг 2-2: результат выполнения <code>cargo build</code> после добавления крейта rand в качестве зависимости</span>

Вы можете увидеть другие номера версий (но все они будут совместимы с кодом благодаря SemVer), другие строки (в зависимости от операционной системы), а также строки могут быть расположены в другом порядке.

Когда мы включаем внешнюю зависимость, Cargo берет последние версии всего, что нужно этой зависимости, из *реестра (registry)*, который является копией данных с [Crates.io]. Crates.io — это место, где участники экосистемы Rust размещают свои проекты с открытым исходным кодом для использования другими.

После обновления реестра Cargo проверяет раздел `[dependencies]` и загружает все указанные в списке пакеты, которые ещё не были загружены. В нашем случае, хотя мы указали только `rand` в качестве зависимости, Cargo также захватил другие пакеты, от которых зависит работа `rand`. После загрузки пакетов Rust компилирует их, а затем компилирует проект с имеющимися зависимостями.

Если сразу же запустить `cargo build` снова, не внося никаких изменений, то кроме строки `Finished` вы не получите никакого вывода. Cargo знает, что он уже загрузил и скомпилировал зависимости, и вы не вносили никаких изменений в файл *Cargo.toml*. Cargo также знает, что вы ничего не изменили в своём коде, поэтому он не перекомпилирует и его. Если делать нечего, он просто завершает работу.

Если вы откроете файл *src/main.rs*, внесёте тривиальное изменение, а затем сохраните его и снова соберёте, вы увидите только две строки вывода:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->

```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```

Эти строки показывают, что Cargo обновляет сборку только с вашим крошечным изменением в файле *src/main.rs*. Ваши зависимости не изменились, поэтому Cargo знает, что может повторно использовать то, что уже скачано и скомпилировано для них.

#### Обеспечение воспроизводимых сборок с помощью файла *Cargo.lock*

В Cargo есть механизм, обеспечивающий возможность пересобрать всё тот же артефакт каждый раз, когда вы или кто-либо другой собирает ваш код. Пока вы не укажете обратное, Cargo будет использовать только те версии зависимостей, которые были заданы ранее. Например, допустим, что на следующей неделе выходит версия 0.8.6 пакета `rand` , и она содержит важное исправление ошибки, но также регрессию, которая может сломать ваш код. Чтобы справиться с этим, Rust создаёт файл *Cargo.lock* при первом запуске `cargo build`, поэтому теперь он есть в каталоге *guessing_game*.

Когда вы создаёте проект в первый раз, Cargo определяет все версии зависимостей, которые соответствуют критериям, а затем записывает их в файл *Cargo.lock*. Когда вы будете собирать свой проект в будущем, Cargo увидит, что файл *Cargo.lock* существует, и будет использовать указанные там версии, а не выполнять всю работу по выяснению версий заново. Это позволяет автоматически создавать воспроизводимую сборку. Другими словами, ваш проект останется на <code>0.8.5</code> до тех пор, пока вы явно не обновите его благодаря файлу *Cargo.lock*. Поскольку файл <em>Cargo.lock</em> важен для воспроизводимых сборок, он часто хранится в системе управления версиями вместе с остальным кодом проекта.

#### Обновление пакета для получения новой версии
"#;
const TWO: &str = r#"
## Функции

Функции широко распространены в коде Rust. Вы уже познакомились с одной из самых важных функций в языке: функцией `main`, которая является точкой входа большинства программ. Вы также видели ключевое слово `fn`, позволяющее объявлять новые функции.

Код Rust использует *змеиный регистр (snake case)* как основной стиль для имён функций и переменных, в котором все буквы строчные, а символ подчёркивания разделяет слова. Вот программа, содержащая пример определения функции:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-16-functions/src/main.rs}}
```

Для определения функции в Rust необходимо указать `fn`, за которым следует имя функции и набор круглых скобок. Фигурные скобки указывают компилятору, где начинается и заканчивается тело функции.

Мы можем вызвать любую функцию, которую мы определили ранее, введя её имя и набор скобок следом. Поскольку в программе определена `another_function`, её можно вызвать из функции `main`. Обратите внимание, что `another_function` определена *после* функции `main` в исходном коде; мы могли бы определить её и раньше. Rust не важно, где вы определяете свои функции, главное, чтобы они были определены где-то в той области видимости, которую может видеть вызывающий их код.

Создадим новый бинарный проект с названием *functions* для дальнейшего изучения функций. Поместите пример `another_function` в файл *src/main.rs* и запустите его. Вы должны увидеть следующий вывод:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-16-functions/output.txt}}
```

Строки выполняются в том порядке, в котором они расположены в функции `main`. Сначала печатается сообщение "Hello, world!", а затем вызывается `another_function`, которая также печатает сообщение.

### Параметры функции

Мы можем определить функции, имеющие *параметры*, которые представляют собой специальные переменные, являющиеся частью сигнатуры функции. Когда у функции есть параметры, необходимо предоставить ей конкретные значения этих параметров. Технически конкретные значения называются *аргументы*, но в повседневном общении люди обычно используют слова *параметр* и *аргумент* как взаимозаменяемые либо для переменных в определении функции, либо для конкретных значений, передаваемых при вызове функции.

В этой версии `another_function` мы добавляем параметр:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/src/main.rs}}
```

Попробуйте запустить эту программу. Должны получить следующий результат:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/output.txt}}
```

Объявление `another_function` содержит один параметр с именем `x`. Тип `x` задан как `i32`. Когда мы передаём `5` в `another_function`, макрос `println!` помещает `5` на место пары фигурных скобок, содержащих `x` в строке формата.

В сигнатурах функций вы *обязаны* указывать тип каждого параметра. Это намеренное решение в дизайне Rust: требование аннотаций типов в определениях функций позволяет компилятору в дальнейшем избежать необходимости использовать их в других местах кода, чтобы определить, какой тип вы имеете в виду. Компилятор также может выдавать более полезные сообщения об ошибках, если он знает, какие типы ожидает функция.

При определении нескольких параметров, разделяйте объявления параметров запятыми, как показано ниже:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/src/main.rs}}
```

Этот пример создаёт функцию под именем `print_labeled_measurement` с двумя параметрами. Первый параметр называется `value` с типом `i32`. Второй называется `unit_label` и имеет тип `char`. Затем функция печатает текст, содержащий `value` и `unit_label`.

Попробуем запустить этот код. Замените текущую программу проекта *functions* в файле *src/main.rs* на предыдущий пример и запустите его с помощью `cargo run`:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/output.txt}}
```

Поскольку мы вызвали функцию с `5` в качестве значения для `value` и `'h'` в качестве значения для `unit_label`, вывод программы содержит эти значения.

### Инструкции и выражения

Тела функций состоят из ряда инструкций, необязательно заканчивающихся выражением. До сих пор функции, которые мы рассматривали, не включали завершающее выражение, но вы видели выражение как часть инструкции. Поскольку Rust является языком, основанным на выражениях, это важное различие необходимо понимать. В других языках таких различий нет, поэтому давайте рассмотрим, что такое инструкции и выражения, и как их различия влияют на тела функций.

- **Инструкции** выполняют какое-либо действие и не возвращают значения.
- **Выражения** вычисляются до результирующего значения. Давайте рассмотрим несколько примеров.

На самом деле мы уже использовали инструкции и выражения. Создание переменной и присвоение ей значения с помощью ключевого слова `let` является оператором. В Листинге 3-1, `let y = 6;` — это инструкция.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-01/src/main.rs}}
```

<span class="caption">Листинг 3-1: Объявление функции <code>main</code>, содержащей одну инструкцию</span>

Определения функций также являются инструкцией. Весь предыдущий пример сам по себе является инструкцией.

Инструкции не возвращают значения. Следовательно вы не можете присвоить `let` инструкцию другой переменной, как это пытается сделать следующий код. Вы получите ошибку:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/src/main.rs}}
```

Если вы запустите эту программу, то ошибка будет выглядеть так:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/output.txt}}
```

Инструкция `let y = 6` не возвращает значение, поэтому не с чем связать переменную `x`. Это отличается от поведения в других языках, таких как C и Ruby, где присваивание возвращает присвоенное значение. В таких языках можно писать код `x = y = 6` и обе переменные `x` и `y` будут иметь значение `6`. Но в Rust не так.

Выражения вычисляют значение и составляют большую часть остального кода, который вы напишете на Rust. Рассмотрим математическую операцию, к примеру `5 + 6`, которая является выражением, вычисляющим значение `11`. Выражения могут быть частью инструкций: в листинге 3-1 `6` в инструкции `let y = 6;` является выражением, которое вычисляется в значение `6`. Вызов функции — это выражение. Вызов макроса — это выражение. Новый блок области видимости, созданный с помощью фигурных скобок, представляет собой выражение, например:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-20-blocks-are-expressions/src/main.rs}}
```

Это выражение:

```rust,ignore
{
    let x = 3;
    x + 1
}
```

это блок, который в данном случае вычисляется в значение `4`. Это значение связывается с `y` как часть инструкции `let`. Обратите внимание, что строка `x + 1` не имеет точки с запятой в конце, что отличается от большинства строк, которые вы видели до сих пор. Выражения не содержат завершающих точек с запятой. Если вы добавите точку с запятой в конец выражения, вы превратите его в инструкцию, и тогда она не будет возвращать значение. Помните об этом, когда будете изучать возвращаемые значения функций и выражения.

### Функции с возвращаемыми значениями

Функции могут возвращать значения коду, который их вызывает. Мы не называем возвращаемые значения, но мы должны объявить их тип после стрелки ( `->` ). В Rust возвращаемое значение функции является синонимом значения конечного выражения в блоке тела функции. Вы можете раньше выйти из функции и вернуть значение, используя ключевое слово `return` и указав значение, но большинство функций неявно возвращают последнее выражение. Вот пример такой функции:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/src/main.rs}}
```

В коде функции `five` нет вызовов функций, макросов или даже инструкций  `let` — есть только одно число `5`. Это является абсолютно корректной функцией в Rust. Заметьте, что возвращаемый тип у данной функции определён как `-> i32`. Попробуйте запустить этот код. Вывод будет таким:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/output.txt}}
```

Значение `5` в `five` является возвращаемым функцией значением, поэтому возвращаемый тип - `i32`. Рассмотрим пример более детально. Здесь есть два важных момента: во-первых, строка `let x = five();` показывает использование возвращаемого функцией значения для инициализации переменной. Так как функция `five` возвращает `5`, то эта строка эквивалентна следующей:

```rust
let x = 5;
```

Во-вторых, у функции `five` нет параметров и определён тип возвращаемого значения, но тело функции представляет собой одинокую `5` без точки с запятой, потому что это выражение, значение которого мы хотим вернуть.

Рассмотрим другой пример:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-22-function-parameter-and-return/src/main.rs}}
```

Запуск кода напечатает `The value of x is: 6`. Но если поставить точку с запятой в конце строки, содержащей `x + 1`, превратив её из выражения в инструкцию, мы получим ошибку:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/src/main.rs}}
```

Компиляция данного кода вызывает следующую ошибку:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/output.txt}}
```

Основное сообщение об ошибке, `несовпадение типов`, раскрывает ключевую проблему этого кода. Определение функции `plus_one` сообщает, что будет возвращено `i32`, но инструкции не вычисляются в значение, что и выражается единичным типом `()`. Следовательно, ничего не возвращается, что противоречит определению функции и приводит к ошибке. В этом выводе Rust выдаёт сообщение, которое, возможно, поможет исправить эту проблему: он предлагает удалить точку с запятой для устранения ошибки.
"#;
const ONE: &str = r#"
## Типы Данных

Каждое значение в Rust относится к определённому *типу данных*, который указывает на вид данных, что позволяет Rust знать, как работать с этими данными. Мы рассмотрим два подмножества типов данных: скалярные и составные.

Не забывайте, что Rust является *статически типизированным* (statically typed) языком. Это означает, что он должен знать типы всех переменных во время компиляции. Обычно компилятор может предположить, какой тип используется (вывести его), основываясь на значении и на том, как мы с ним работаем. В случаях, когда может быть выведено несколько типов, необходимо добавлять аннотацию типа вручную. Например, когда мы конвертировали `String` в число с помощью вызова `parse` в разделе [«Сравнение предположения с загаданным номером»](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number) главы 2, мы должны добавить такую аннотацию:<!-- ignore -->

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

Если мы не добавим аннотацию типа `: u32`, показанную в предыдущем коде, Rust отобразит следующую ошибку, которая означает, что компилятору нужно от нас больше информации, чтобы узнать, какой тип мы хотим использовать:

```console
{{#include ../listings/ch03-common-programming-concepts/output-only-01-no-type-annotations/output.txt}}
```

В будущем вы увидите различные аннотации для разных типов данных.

### Скалярные типы данных

*Скалярный* тип представляет собой единичное значение. В Rust есть четыре основных скалярных типа: целочисленный, числа с плавающей точкой, логический и символы. Вы наверняка знакомы с этими типами по другим языкам программирования. Давайте разберёмся, как они работают в Rust.

#### Целочисленные типы

Целочисленный тип (*integer*) — это число без дробной части. В главе 2 мы использовали один целочисленный тип — тип `u32`. Такое объявление типа указывает, что значение, с которым оно связано, должно быть целым числом без знака (типы целых чисел со знаком начинаются с `i` вместо `u`), которое занимает 32 бита памяти. В Таблице 3-1 показаны встроенные целочисленные типы в Rust. Мы можем использовать любой из этих вариантов для объявления типа целочисленного значения.

<span class="caption">Таблица 3-1: целочисленные типы в Rust</span>

Длина | Со знаком | Без знака
--- | --- | ---
8 бит | `i8` | `u8`
16 бит | `i16` | `u16`
32 бита | `i32` | `u32`
64 бита | `i64` | `u64`
128 бит | `i128` | `u128`
архитектурно-зависимая | `isize` | `usize`

Каждый вариант может быть как со знаком, так и без знака и имеет явный размер. Такая характеристика типа как *знаковый* и *беззнаковый* определяет возможность числа быть отрицательным. Другими словами, должно ли число иметь знак (знаковое) или оно всегда будет только положительным и, следовательно, может быть представлено без знака (беззнаковое). Это похоже на написание чисел на бумаге: когда знак имеет значение, число отображается со знаком плюс или со знаком минус; однако, когда можно с уверенностью предположить, что число положительное, оно отображается без знака. Числа со знаком хранятся с использованием [дополнительного кода].

Каждый вариант со знаком может хранить числа от -(2 <sup>n - 1</sup> ) до 2 <sup>n - 1</sup> - 1 включительно, где *n* — количество битов, которые использует этот вариант. Таким образом, `i8` может хранить числа от -(2 <sup>7</sup> ) до 2 <sup>7</sup> - 1, что равно значениям от -128 до 127. Варианты без знака могут хранить числа от 0 до 2 <sup>n</sup> - 1, поэтому `u8` может хранить числа от 0 до 2 <sup>8</sup> - 1, что равно значениям от 0 до 255.

Кроме того, типы `isize` и `usize` зависят от архитектуры компьютера, на котором выполняется программа, и обозначаются в таблице как "arch": 64 бита, если используется 64-битная архитектура, и 32 бита, если используется 32-битная архитектура.

Вы можете записывать целочисленные литералы в любой из форм, показанных в таблице 3-2. Заметьте, что числовые литералы, имеющие несколько числовых типов, допускают использование суффикса типа, например `57u8`, для обозначения типа. Числовые литералы также могут использовать `_` в качестве визуального разделителя для облегчения чтения числа, например `1_000`, который будет иметь такое же значение, как если бы было задано `1000`.

<span class="caption">Таблица 3-2: Целочисленные литералы в Rust</span>

Числовой литерал | Пример
--- | ---
Десятичный | `98_222`
Шестнадцатеричный | `0xff`
восьмеричный | `0o77`
Двоичный | `0b1111_0000`
Байт (только `u8`) | `b'A'`

Как же узнать, какой тип целого числа использовать? Если вы не уверены, значения по умолчанию в Rust, как правило, подходят для начала: целочисленные типы по умолчанию `i32`. Основной случай, в котором вы должны использовать `isize` или `usize`, — это индексация какой-либо коллекции.

>  <h>Целочисленное переполнение</h> Допустим, имеется переменная типа `u8`, которая может хранить значения от 0 до 255. Если попытаться изменить переменную на значение вне этого диапазона, например, 256, произойдёт *целочисленное переполнение*, что может привести к одному из двух вариантов поведения. Если выполняется компиляция в режиме отладки, Rust включает проверку на целочисленное переполнение, приводящую вашу программу к *панике* во время выполнения, когда возникает такое поведение. Rust использует термин *паника(panicking)*, когда программа завершается с ошибкой. Мы обсудим панику более подробно в разделе ["Неустранимые ошибки с `panic!`"] в главе 9. . При компиляции в режиме release с флагом `--release`, Rust *не* включает проверки на целочисленное переполнение, которое вызывает панику. Вместо этого, в случае переполнения, Rust выполняет *обёртывание второго дополнения*. Проще говоря, значения, превышающие максимальное значение, которое может хранить тип, "оборачиваются" к минимальному из значений, которые может хранить тип. В случае `u8` значение 256 становится 0, значение 257 становится 1, и так далее. Программа не запаникует, но переменная будет иметь значение, которое, вероятно, не будет соответствовать вашим ожиданиям. Полагаться на поведение обёртывания целочисленного переполнения считается ошибкой. Для явной обработки возможности переполнения существует семейство методов, предоставляемых стандартной библиотекой для примитивных числовых типов:
>  - Обёртывание во всех режимах с помощью методов `wrapping_*`, таких как `wrapping_add`.
> - Возврат значения `None` при переполнении с помощью методов `checked_*`.
> - Возврат значения и логический индикатор, указывающий, произошло ли переполнение при использовании методов `overflowing_*`.
> - Насыщение минимальным или максимальным значением с помощью методов `saturating_*`.
>

#### Числа с плавающей запятой

Также в Rust есть два примитивных типа для чисел с плавающей запятой, представляющих собой числа с десятичной точкой. Типы с плавающей точкой в Rust - это f32 и f64, размер которых составляет 32 бита и 64 бита соответственно. По умолчанию используется тип f64, поскольку на современных процессорах он работает примерно с той же скоростью, как и f32, но обладает большей точностью. Все типы с плавающей запятой являются знаковыми.

Вот пример, демонстрирующий числа с плавающей запятой в действии:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-06-floating-point/src/main.rs}}
```

Числа с плавающей запятой представлены в соответствии со стандартом IEEE-754. Тип `f32` является плавающей запятой одинарной точности, а `f64` - двойной точности.

#### Числовые операции

Rust поддерживает основные математические операции, привычные для всех типов чисел: сложение, вычитание, умножение, деление и остаток. Целочисленное деление обрезает значение в направлении нуля до ближайшего целого числа. Следующий код показывает, как можно использовать каждую числовую операцию в инструкции `let`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-07-numeric-operations/src/main.rs}}
```

Каждое выражение в этих инструкциях использует математический оператор и вычисляется в одно значение, которое связывается с переменной. [Приложении B](appendix-02-operators.html) содержит список всех операторов, которые предоставляет Rust.

#### Логический тип данных

Как и в большинстве других языков программирования, логический тип в Rust имеет два возможных значения: `true` и `false`. Значения логических типов имеют размер в один байт. Логический тип в Rust задаётся с помощью `bool`. Например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-08-boolean/src/main.rs}}
```

Основной способ использования логических значений - это использование условий, таких как выражение `if`. Мы рассмотрим, как выражения `if` работают в Rust в разделе ["Поток управления"].

#### Символьный тип данных

Тип `char` в Rust является самым примитивным алфавитным типом языка. Вот несколько примеров объявления значений `char`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-09-char/src/main.rs}}
```

Заметьте, мы указываем литералы `char` с одинарными кавычками, в отличие от строковых литералов, для которых используются двойные кавычки. Тип `char` в Rust имеет размер четыре байта и представляет собой скалярное значение Unicode, а значит, может представлять собой не только ASCII. Акцентированные буквы, китайские, японские и корейские символы, эмодзи и пробелы нулевой ширины - все это допустимые значения типа `char` в Rust. Скалярные значения Unicode находятся в диапазоне от `U+0000` до `U+D7FF` и от `U+E000` до `U+10FFFF` включительно. Однако "символ" не является понятием в Unicode, поэтому ваше человеческое представление о том, что такое "символ", может не совпадать с тем, что такое `char` в Rust. Мы подробно обсудим эту тему в главе 8 "Хранение текста в кодировке UTF-8 с помощью строк".

### Составные типы данных

*Составные типы* могут группировать различные значения в один тип. В Rust есть два примитивных составных типа: кортежи и массивы.

#### Кортежи

*Кортеж*- это универсальный способ объединения нескольких значений с различными типами в один составной тип. Кортежи имеют фиксированную длину: после объявления они не могут увеличиваться или уменьшаться в размерах.

Мы создаём кортеж, записывая список значений, разделённых запятыми, внутри круглых скобок. Каждая позиция в кортеже имеет тип, причём типы различных значений в кортеже не обязательно должны быть одинаковыми. В этом примере мы добавили необязательные аннотации типов:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-10-tuples/src/main.rs}}
```

Переменная `tup` связана со всем кортежем, поскольку кортеж является одним составным элементом. Чтобы получить отдельные значения из кортежа, можно использовать сопоставление с образцом для деструктуризации значения кортежа, например, так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-11-destructuring-tuples/src/main.rs}}
```

Эта программа сначала создаёт кортеж и связывает его с переменной `tup`. Затем с помощью шаблона `let` берётся `tup` и превращается в три отдельные переменные, `x`, `y` и `z`. Это называется *деструктуризацией*, поскольку разбивает единый кортеж на три части. Наконец, программа печатает значение `y`, которое равно `6.4`.

Мы также можем получить доступ к элементу кортежа напрямую, используя точку (`.`), за которой следует индекс значения, требуемого для доступа. Например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-12-tuple-indexing/src/main.rs}}
```

Эта программа создаёт кортеж `x`, а затем обращается к каждому элементу кортежа, используя соответствующие индексы. Как и в большинстве языков программирования, первый индекс в кортеже равен 0.

Кортеж, не имеющий значений, имеет специальное имя  *единичный тип (unit)*. Это значение и соответствующий ему тип записываются как `()` и представляет собой пустое значение или пустой возвращаемый тип. Выражения неявно возвращают значение единичного типа, если не возвращают никакого другого значения.

#### Массивы

Другим способом создания коллекции из нескольких значений является массив *array*. В отличие от кортежа, каждый элемент массива должен иметь один и тот же тип. В отличие от массивов в некоторых других языках, массивы в Rust имеют фиксированную длину.

Мы записываем значения в массиве в виде списка, разделённого запятыми, внутри квадратных скобок:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-13-arrays/src/main.rs}}
```

Массивы удобно использовать, если данные необходимо разместить в стеке, а не в куче (мы подробнее обсудим стек и кучу в [Главе 4]) или если требуется, чтобы количество элементов всегда было фиксированным. Однако массив не так гибок, как вектор. *Вектор* - это аналогичный тип коллекции, предоставляемый стандартной библиотекой, который *может* увеличиваться или уменьшаться в размере. Если вы не уверены, что лучше использовать - массив или вектор, то, скорее всего, вам следует использовать вектор. Более подробно векторы рассматриваются в [Главе 8].

Однако массивы более полезны, когда вы знаете, что количество элементов не нужно будет изменять. Например, если бы вы использовали названия месяцев в программе, вы, вероятно, использовали бы массив, а не вектор, потому что вы знаете, что он всегда будет содержать 12 элементов:

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

Тип массива записывается следующим образом: в квадратных скобках обозначается тип элементов массива, а затем, через точку с запятой, количество элементов. Например:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

Здесь `i32` является типом каждого элемента массива. После точки с запятой указано число `5`, показывающее, что массив содержит 5 элементов.

Вы также можете инициализировать массив, содержащий одно и то же значение для каждого элемента, указав это значение вместо типа. Следом за этим так же следует точка с запятой, а затем — длина массива в квадратных скобках, как показано здесь:

```rust
let a = [3; 5];
```

Массив в переменной `a` будет включать `5` элементов, значение которых будет равно `3`. Данная запись аналогична коду `let a = [3, 3, 3, 3, 3];`, но является более краткой.

##### Доступ к элементам массива

Массив — это единый фрагмент памяти известного фиксированного размера, который может быть размещён в стеке. Вы можете получить доступ к элементам массива с помощью индексации, например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-14-array-indexing/src/main.rs}}
```

В этом примере переменная с именем first получит значение 1, потому что это значение находится по индексу [0] в массиве. Переменная с именем second получит значение 2 по индексу [1] в массиве.

##### Некорректный доступ к элементу массива

Давайте посмотрим, что произойдёт, если попытаться получить доступ к элементу массива, находящемуся за его пределами. Допустим, вы запускаете данный код, похожий на игру в угадывание из Главы 2, чтобы получить от пользователя индекс массива:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,panics
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access/src/main.rs}}
```

Этот код успешно компилируется. Если запустить этот код с помощью `cargo run` и ввести `0`, `1`, `2`, `3` или `4`, программа напечатает соответствующее значение по данному индексу в массиве. Если вместо этого ввести число за пределами массива, например, `10`, то программа выведет следующее:

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->

```console
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

Программа столкнулась с ошибкой во *времени выполнения* на этапе применения недопустимого значения в операции индексирования. Программа завершилась с сообщением об ошибке и не выполнила финальную инструкцию `println!`. При попытке доступа к элементу с помощью индексирования Rust проверяет, что указанный индекс меньше длины массива. Если индекс больше или равен длине, Rust паникует. Эта проверка должна происходить во время выполнения, особенно в данном случае, потому что компилятор не может знать, какое значение введёт пользователь при последующем выполнении кода.

Это пример принципов безопасности памяти Rust в действии. Во многих низкоуровневых языках такая проверка не выполняется, и когда вы указываете неправильный индекс, доступ к памяти может быть некорректным. Rust защищает вас от такого рода ошибок, немедленно закрываясь вместо того, чтобы разрешать доступ к памяти и продолжать работу. В главе 9 подробнее обсуждается обработка ошибок в Rust и то, как вы можете написать читаемый, безопасный код, который не вызывает панику и не разрешает некорректный доступ к памяти.


[дополнительного кода]: https://en.wikipedia.org/wiki/Two%27s_complement
["Поток управления"]: ch03-05-control-flow.html#control-flow
[Главе 4]: ch04-01-what-is-ownership.html#the-stack-and-the-heap
[Главе 8]: ch08-01-vectors.html
["Неустранимые ошибки с `panic!`"]: ch09-01-unrecoverable-errors-with-panic.html
"#;